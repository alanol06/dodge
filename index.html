<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png">
    <title>Block Dodge Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            color: white;
            font-family: 'Orbitron', monospace;
        }
        canvas {
            display: block;
            background-image: 
                linear-gradient(0deg, transparent 24%, rgba(0, 255, 255, 0.05) 25%, rgba(0, 255, 255, 0.05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 255, 0.05) 75%, rgba(0, 255, 255, 0.05) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(0, 255, 255, 0.05) 25%, rgba(0, 255, 255, 0.05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 255, 0.05) 75%, rgba(0, 255, 255, 0.05) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
        }
        #upgradeMenu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(20, 10, 40, 0.95) 100%);
            padding: 25px;
            border: 3px solid #00ffff;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.1);
        }
        #upgradeMenu h2 {
            margin-bottom: 15px;
            font-size: 24px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            letter-spacing: 2px;
        }
        #upgradeMenu p {
            font-size: 14px;
            margin: 8px 0;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        #upgradeMenu .upgrades {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #00ff00;
            border-radius: 10px;
        }
        #upgradeMenu .upgrade {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.2) 0%, rgba(0, 255, 100, 0.1) 100%);
            position: relative;
            cursor: pointer;
            border: 2px solid #00ff00;
            border-radius: 8px;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        #upgradeMenu .upgrade:hover {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.4) 0%, rgba(0, 255, 100, 0.2) 100%);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            border-color: #00ffff;
        }
        #upgradeMenu .upgrade .fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #00ff00, #00ff88);
            opacity: 0.8;
        }
        #upgradeMenu .upgrade .label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 11px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 5px #00ffff;
            z-index: 2;
        }
        #upgradeMenu .upgrade .cost {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            z-index: 2;
            color: #ffff00;
            text-shadow: 0 0 3px #ffff00;
        }
        #upgradeMenu .abilities {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #ff00ff;
            border-radius: 10px;
        }
        #upgradeMenu .abilities h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }
        #upgradeMenu .ability {
            display: inline-block;
            margin: 8px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2) 0%, rgba(200, 0, 255, 0.1) 100%);
            cursor: pointer;
            text-align: center;
            border: 2px solid #ff00ff;
            border-radius: 8px;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
            min-width: 130px;
            font-size: 12px;
        }
        #upgradeMenu .ability:hover {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.4) 0%, rgba(200, 0, 255, 0.2) 100%);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.6);
            border-color: #00ffff;
        }
        #upgradeMenu .ability.selected {
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }
        #upgradeMenu .ability .cost {
            font-size: 11px;
            display: block;
            margin: 6px 0;
            color: #ffff00;
            text-shadow: 0 0 3px #ffff00;
        }
        #upgradeMenu .ability button {
            margin: 3px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #00ff00, #00ff88);
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s;
            font-family: 'Orbitron', monospace;
            font-size: 10px;
        }
        #upgradeMenu .ability button:hover {
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
            transform: scale(1.05);
        }
        #upgradeMenu .ability button.select {
            background: linear-gradient(135deg, #ffff00, #ffff88);
            color: #000;
        }
        #restartButton {
            margin-top: 15px;
            padding: 10px 25px;
            background: linear-gradient(135deg, #ff0080, #ff0040);
            color: white;
            border: 2px solid #ff0080;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 0, 128, 0.5);
        }
        #resetProgressButton {
            margin-top: 15px;
            padding: 10px 25px;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
            border: 2px solid #ff4444;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 999;
        }
        #resetProgressButton:hover {
            background: linear-gradient(135deg, #ff6666, #dd0000);
            box-shadow: 0 0 25px rgba(255, 68, 68, 0.8);
            transform: scale(1.05);
        }
        #resetProgressButton.visible {
            display: block;
        }
        #authorLabel {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            display: none;
            z-index: 998;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        #authorLabel.visible {
            display: block;
        }
        #debugPanel {
            display: none;
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            z-index: 1000;
        }
        #debugPanel button {
            display: block;
            width: 100%;
            margin: 8px 0;
            padding: 10px;
            background: linear-gradient(135deg, #ff00ff, #ff0080);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }
        #debugPanel button:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            transform: scale(1.05);
        }
        #achievementsContainer {
            display: none;
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            max-height: 70vh;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(20, 10, 40, 0.95) 100%);
            border: 3px solid #ff00ff;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5), inset 0 0 30px rgba(255, 0, 255, 0.1);
            overflow-y: auto;
        }
        #achievementsContainer h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            text-align: center;
        }
        .achievement-item {
            background: rgba(255, 0, 255, 0.1);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 11px;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }
        .achievement-item.earned {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .achievement-item .name {
            display: block;
            font-weight: 700;
            margin-bottom: 4px;
            color: #ffffff;
            text-shadow: 0 0 5px #ff00ff;
        }
        .achievement-item.earned .name {
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .achievement-item .progress-bar {
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            margin-top: 6px;
            overflow: hidden;
            border: 1px solid #ff00ff;
        }
        .achievement-item .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #ff0088);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        .achievement-item.earned .progress-bar-fill {
            background: linear-gradient(90deg, #00ffff, #00ff88);
        }
        .achievement-item .progress {
            display: block;
            font-size: 10px;
            margin-top: 3px;
        }
        .achievement-item .points {
            display: block;
            font-size: 10px;
            color: #00ff00;
            text-shadow: 0 0 3px #00ff00;
            margin-top: 3px;
        }
        #achievementsContainer .achievement-points {
            text-align: center;
            padding: 10px 0;
            border-top: 2px solid #ff00ff;
            border-bottom: 2px solid #ff00ff;
            margin-bottom: 12px;
            font-size: 12px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            font-weight: 700;
        }
        #notificationContainer {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 2000;
            pointer-events: none;
        }
        .notification {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.95) 0%, rgba(0, 200, 255, 0.95) 100%);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8), inset 0 0 20px rgba(0, 255, 255, 0.2);
            animation: slideIn 0.5s ease-out, slideOut 0.5s ease-in 2.5s forwards;
            max-width: 280px;
            color: #000;
            font-weight: 700;
            text-align: center;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
        }
        .notification .achievement-title {
            display: block;
            font-size: 14px;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #00ffff;
        }
        .notification .achievement-reward {
            display: block;
            font-size: 12px;
            color: #ff6600;
            text-shadow: 0 0 5px #ff6600;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Skins shop styles */
        .skins {
            margin-top: 20px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.35);
            border: 2px solid #00ffff;
            border-radius: 10px;
            text-align: left;
        }
        .skins h3 {
            margin: 0 0 10px 0;
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            font-size: 16px;
        }
        .skin-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .skin-tile {
            width: 92px;
            height: 92px;
            background: rgba(255,255,255,0.02);
            border: 2px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            padding: 6px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: #fff;
        }
        .skin-preview {
            width: 68px;
            height: 46px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.06);
            box-shadow: 0 0 8px rgba(0,0,0,0.4) inset;
        }
        .skin-actions {
            width: 100%;
            display: flex;
            gap: 4px;
            justify-content: center;
        }
        .skin-actions button {
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 700;
        }
        .skin-owned { border-color: #00ff88; }
        .skin-selected { box-shadow: 0 0 12px #ffff66; border-color: #ffff66; }
        .skins .skins-content { max-height: 800px; overflow-y: auto; transition: max-height 0.35s ease; }
        .skins.collapsed .skins-content { max-height: 0; }
        .skins-toggle {
            float: right;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.06);
            color: #00ffff;
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            font-size: 12px;
        }

    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="authorLabel">Made by alanol06</div>
    <div id="debugPanel">
        <button id="debugCurrency">+50 –í–∞–ª—é—Ç–∞</button>
        <button id="debugCoins">+50 –ú–æ–Ω–µ—Ç</button>
        <button id="debugTime">+10 –°–µ–∫</button>
    </div>
    <div id="achievementsContainer">
        <h3>üèÜ –î–û–°–¢–ò–ñ–ï–ù–ò–Ø üèÜ</h3>
        <div class="achievement-points">üèÜ –û—á–∫–∏: <span id="achievementPointsDisplay">0</span></div>
        <!-- Achievements will be generated here -->
    </div>
    <div id="notificationContainer"></div>
    <div id="upgradeMenu">
        <p style="margin-top: 0; color: #00ffff; font-size: 13px; text-shadow: 0 0 5px #00ffff;">‚è± –õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: <span id="bestTimeDisplay">00:00</span></p>
        <h2>‚ö° –ü–†–û–ö–ê–ß–ö–ê ‚ö°</h2>
        <p>üí∞ –í–∞–ª—é—Ç–∞ —É–∫–ª–æ–Ω–µ–Ω–∏–π: <span id="currencyDisplay">0</span></p>
        <div class="upgrades">
            <!-- Upgrades will be generated here -->
        </div>
        <p>‚ú® –û—á–∫–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π: <span id="abilityPoints">0</span></p>
        <div class="abilities">
            <!-- Abilities will be generated here -->
        </div>
        <div class="skins" id="skinsWrapper">
            <h3>üé® –°–∫–∏–Ω—ã (–ø–æ–∫—É–ø–∞—é—Ç—Å—è –∑–∞ –æ—á–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π) <button id="skinsToggle" class="skins-toggle">–ü–æ–∫–∞–∑–∞—Ç—å</button></h3>
            <div class="skins-content" id="skinsContent">
                <p style="margin:6px 0 10px 0; font-size:12px; color:#00ff88;">–û—á–∫–∏: <span id="achievementPointsInline">0</span></p>
                <div id="skinsSection">
                    <!-- Skins UI will be generated here -->
                </div>
            </div>
        </div>
        <button id="restartButton">üéÆ –ù–ê–ß–ê–¢–¨ –ó–ê–ù–û–í–û üéÆ</button>
    </div>
    <button id="resetProgressButton">üîÑ –°–ë–†–û–° üîÑ</button>


    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const upgradeMenu = document.getElementById('upgradeMenu');

        // –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–Ω–≤–∞—Å
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        let gameState = 'playing';
        let player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            baseSize: 90,
            size: 90,
            speed: 0.05,
            hp: 10,
            maxHp: 10,
            regen: 0,
            damageReduce: 0
        };
        let frame = {
            size: 400,
            x: (canvas.width - 400) / 2,
            y: (canvas.height - 400) / 2
        };
        let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
        let leftMouseDown = false;
        let projectiles = [];
        let powerUps = [];
        let timeBonuses = [];
        let projectileTypes = [0];
        let lastSpawn = 0;
        let spawnInterval = 1000;
        let projectileSpeed = 2;
        let timeElapsed = 0;
        let lastMinute = 0;
        let dodges = { 0: 0, 1: 0, 2: 0, 3: 0 };
        let currencyBonus = 1.0;
        let abilityPoints = 0;
        let lastPowerUpSpawn = 0;
        let powerUpSpawnInterval = 10000; // –±–∞–∑–æ–≤—ã–π, –±—É–¥–µ—Ç –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω –≤ applyUpgrades
        let particles = [];
        let screenShake = 0;
        let maxTimeElapsed = 0; // –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–æ–∂–∏—Ç–æ–µ –≤—Ä–µ–º—è

        // –£–ª—É—á—à–µ–Ω–∏—è
        const maxLevel = 10;
        let upgrades = {
            hp: { level: 1, cost: 10 },
            currency: { level: 1, cost: 15 },
            speed: { level: 1, cost: 20 },
            regen: { level: 0, cost: 25 },
            damage: { level: 0, cost: 20 },
            frame: { level: 1, cost: 30 },
            powerup: { level: 0, cost: 20 },
            shrink: { level: 0, cost: 18 } // –Ω–æ–≤–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∏–≥—Ä–æ–∫–∞
        };
        const upgradeLabels = {
            hp: 'HP',
            currency: '–í–∞–ª—é—Ç–∞',
            speed: '–°–∫–æ—Ä–æ—Å—Ç—å',
            regen: '–†–µ–≥–µ–Ω',
            damage: '–£—Ä–æ–Ω -',
            frame: '–†–∞–º–∫–∞',
            powerup: '–ß–∞—Å—Ç–æ—Ç–∞\n–º–æ–Ω–µ—Ç',
            shrink: '–†–∞–∑–º–µ—Ä -'
        };

        // –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
        let abilities = {
            shield: { owned: false, cost: 5, level: 0, maxCharge: 5, charge: 5, regen: 1, drainRate: 1 },
            shrink: { owned: false, cost: 5, level: 0, maxCharge: 5, charge: 5, regen: 1, drainRate: 1 },
            slow: { owned: false, cost: 5, level: 0, maxCharge: 5, charge: 5, regen: 1, drainRate: 1 }
        };
        let activeAbility = null;
        const abilityLabels = {
            shield: '–©–∏—Ç',
            shrink: '–£–º–µ–Ω—å—à–µ–Ω–∏–µ',
            slow: '–ó–∞–º–µ–¥–ª–µ–Ω–∏–µ'
        };

        // –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        let achievementPoints = 0;
        let dodgeCount = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
        let maxedUpgrades = 0;
        let unlockedAbilities = 0;
        const achievements = {
            dodge0: { 
                name: 'üöÄ –°–Ω–∞—Ä—è–¥—ã –¢–∏–ø 1', 
                milestones: [100, 300, 700], 
                earned: [false, false, false], 
                points: [25, 50, 75] 
            },
            dodge1: { 
                name: 'üî• –°–Ω–∞—Ä—è–¥—ã –¢–∏–ø 2', 
                milestones: [100, 200, 500, 1000], 
                earned: [false, false, false, false], 
                points: [25, 40, 60, 100] 
            },
            dodge3: { 
                name: '‚öôÔ∏è –õ–æ–≤—É—à–∫–∏', 
                milestones: [70, 150, 220, 300], 
                earned: [false, false, false, false], 
                points: [25, 40, 60, 100] 
            },
            dodge2: { 
                name: '‚ö° –õ–∞–∑–µ—Ä—ã', 
                milestones: [25, 50, 75, 100], 
                earned: [false, false, false, false], 
                points: [25, 40, 60, 100] 
            },
            dodge4: { 
                name: 'üíÄ –£—Ä–æ–Ω –∑–æ–Ω—ã', 
                milestones: [30, 60, 100, 150], 
                earned: [false, false, false, false], 
                points: [30, 50, 75, 100] 
            },
            timeAlive: { 
                name: '‚è±Ô∏è –í—ã–∂–∏–≤–∞–Ω–∏–µ', 
                milestones: [30, 60, 90, 120, 150, 180, 210, 240, 270, 300], 
                earned: [false, false, false, false, false, false, false, false, false, false], 
                points: [20, 25, 30, 40, 50, 60, 70, 80, 90, 150] 
            },
            maxUpgrades: { 
                name: 'üìà –ê–ø–≥—Ä–µ–π–¥—ã', 
                milestones: [1, 2, 3, 4, 5, 6, 7, 8], 
                earned: [false, false, false, false, false, false, false, false], 
                points: [30, 30, 30, 30, 30, 30, 30, 30] 
            },
            abilityUnlock: { 
                name: '‚ú® –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', 
                milestones: [1, 2, 3], 
                earned: [false, false, false], 
                points: [40, 40, 40] 
            }
        };

        // Skins animation phase (for –ø–µ—Ä–µ–ª–∏–≤–∞—é—â–∏–π—Å—è)
        let skinAnimPhase = 0;

        // Cosmic starfield and gold sparkle data
        let cosmicStars = [];
        let goldSparkles = [];

        function ensureCosmicStars() {
            const area = canvas.width * canvas.height;
            const count = Math.max(60, Math.floor(area / 20000));
            if (cosmicStars.length === count) return;
            cosmicStars = [];
            for (let i = 0; i < count; i++) {
                cosmicStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.6 + 0.4,
                    baseAlpha: 0.12 + Math.random() * 0.6,
                    speed: 0.5 + Math.random() * 1.2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function ensureGoldSparkles() {
            const count = 18;
            if (goldSparkles.length === count) return;
            goldSparkles = [];
            for (let i = 0; i < count; i++) {
                goldSparkles.push({
                    angle: Math.random() * Math.PI * 2,
                    radius: 8 + Math.random() * (player.baseSize / 1.1),
                    speed: (0.6 + Math.random() * 1.2) * (Math.random() < 0.5 ? -1 : 1),
                    size: 1 + Math.random() * 3,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∫–∞–∑–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è—Ö
        function showAchievementNotification(name, points) {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `<div class="achievement-title">üéâ ${name}</div><div class="achievement-reward">+${points} –æ—á–∫–æ–≤</div>`;
            container.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
        function checkAchievements() {
            let earnedAny = false;
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç —Å–Ω–∞—Ä—è–¥–æ–≤ —Ç–∏–ø–∞ 0
            for (let i = 0; i < achievements.dodge0.milestones.length; i++) {
                if (dodgeCount[0] >= achievements.dodge0.milestones[i] && !achievements.dodge0.earned[i]) {
                    achievements.dodge0.earned[i] = true;
                    achievementPoints += achievements.dodge0.points[i];
                    showAchievementNotification(`${achievements.dodge0.name} ${achievements.dodge0.milestones[i]}`, achievements.dodge0.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç —Å–Ω–∞—Ä—è–¥–æ–≤ —Ç–∏–ø–∞ 1
            for (let i = 0; i < achievements.dodge1.milestones.length; i++) {
                if (dodgeCount[1] >= achievements.dodge1.milestones[i] && !achievements.dodge1.earned[i]) {
                    achievements.dodge1.earned[i] = true;
                    achievementPoints += achievements.dodge1.points[i];
                    showAchievementNotification(`${achievements.dodge1.name} ${achievements.dodge1.milestones[i]}`, achievements.dodge1.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç –ª–∞–∑–µ—Ä–æ–≤ (—Ç–∏–ø 2)
            for (let i = 0; i < achievements.dodge2.milestones.length; i++) {
                if (dodgeCount[2] >= achievements.dodge2.milestones[i] && !achievements.dodge2.earned[i]) {
                    achievements.dodge2.earned[i] = true;
                    achievementPoints += achievements.dodge2.points[i];
                    showAchievementNotification(`${achievements.dodge2.name} ${achievements.dodge2.milestones[i]}`, achievements.dodge2.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç –ª–æ–≤—É—à–µ–∫ (—Ç–∏–ø 3)
            for (let i = 0; i < achievements.dodge3.milestones.length; i++) {
                if (dodgeCount[3] >= achievements.dodge3.milestones[i] && !achievements.dodge3.earned[i]) {
                    achievements.dodge3.earned[i] = true;
                    achievementPoints += achievements.dodge3.points[i];
                    showAchievementNotification(`${achievements.dodge3.name} ${achievements.dodge3.milestones[i]}`, achievements.dodge3.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç –∑–æ–Ω –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è (—Ç–∏–ø 4)
            for (let i = 0; i < achievements.dodge4.milestones.length; i++) {
                if (dodgeCount[4] >= achievements.dodge4.milestones[i] && !achievements.dodge4.earned[i]) {
                    achievements.dodge4.earned[i] = true;
                    achievementPoints += achievements.dodge4.points[i];
                    showAchievementNotification(`${achievements.dodge4.name} ${achievements.dodge4.milestones[i]}`, achievements.dodge4.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–∂–∏–≤–∞–Ω–∏—è
            for (let i = 0; i < achievements.timeAlive.milestones.length; i++) {
                if (timeElapsed >= achievements.timeAlive.milestones[i] && !achievements.timeAlive.earned[i]) {
                    achievements.timeAlive.earned[i] = true;
                    achievementPoints += achievements.timeAlive.points[i];
                    showAchievementNotification(`${achievements.timeAlive.name} ${achievements.timeAlive.milestones[i]}—Å–µ–∫`, achievements.timeAlive.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–∫—Å–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∞–ø–≥—Ä–µ–π–¥–æ–≤
            let currentMaxed = 0;
            Object.keys(upgrades).forEach(key => {
                if (upgrades[key].level === maxLevel) currentMaxed++;
            });
            for (let i = 0; i < achievements.maxUpgrades.milestones.length; i++) {
                if (currentMaxed >= achievements.maxUpgrades.milestones[i] && !achievements.maxUpgrades.earned[i]) {
                    achievements.maxUpgrades.earned[i] = true;
                    achievementPoints += achievements.maxUpgrades.points[i];
                    showAchievementNotification(`${achievements.maxUpgrades.name} ${achievements.maxUpgrades.milestones[i]}/8`, achievements.maxUpgrades.points[i]);
                    earnedAny = true;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            let currentUnlocked = 0;
            Object.keys(abilities).forEach(key => {
                if (abilities[key].owned) currentUnlocked++;
            });
            for (let i = 0; i < achievements.abilityUnlock.milestones.length; i++) {
                if (currentUnlocked >= achievements.abilityUnlock.milestones[i] && !achievements.abilityUnlock.earned[i]) {
                    achievements.abilityUnlock.earned[i] = true;
                    achievementPoints += achievements.abilityUnlock.points[i];
                    showAchievementNotification(`${achievements.abilityUnlock.name} ${achievements.abilityUnlock.milestones[i]}/3`, achievements.abilityUnlock.points[i]);
                    earnedAny = true;
                }
            }
            if (earnedAny) {
                saveProgress();
                updateAchievementsDisplay();
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–µ–Ω—é –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
        function updateAchievementsDisplay() {
            const container = document.getElementById('achievementsContainer');
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—á–∫–æ–≤ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
            const achievePointsSpan = container.querySelector('#achievementPointsDisplay');
            if (achievePointsSpan) {
                achievePointsSpan.textContent = achievementPoints;
            }
            
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è (–≤—Å–µ –∫—Ä–æ–º–µ h3 –∏ achievement-points)
            const existingItems = container.querySelectorAll('.achievement-item');
            existingItems.forEach(item => item.remove());
            
            const wrapper = document.createElement('div');
            
            Object.keys(achievements).forEach(key => {
                const ach = achievements[key];
                for (let i = 0; i < ach.milestones.length; i++) {
                    const div = document.createElement('div');
                    div.className = 'achievement-item' + (ach.earned[i] ? ' earned' : '');
                    const name = document.createElement('span');
                    name.className = 'name';
                    name.textContent = `${ach.name} ${i + 1}/${ach.milestones.length}`;
                    
                    let currentProgress = 0;
                    if (key === 'dodge0') {
                        currentProgress = Math.min(dodgeCount[0], ach.milestones[i]);
                    } else if (key === 'dodge1') {
                        currentProgress = Math.min(dodgeCount[1], ach.milestones[i]);
                    } else if (key === 'dodge2') {
                        currentProgress = Math.min(dodgeCount[2], ach.milestones[i]);
                    } else if (key === 'dodge3') {
                        currentProgress = Math.min(dodgeCount[3], ach.milestones[i]);
                    } else if (key === 'dodge4') {
                        currentProgress = Math.min(dodgeCount[4], ach.milestones[i]);
                    } else if (key === 'timeAlive') {
                        currentProgress = Math.floor(Math.min(timeElapsed, ach.milestones[i]));
                    } else if (key === 'maxUpgrades') {
                        let currentMaxed = 0;
                        Object.keys(upgrades).forEach(k => {
                            if (upgrades[k].level === maxLevel) currentMaxed++;
                        });
                        currentProgress = Math.min(currentMaxed, ach.milestones[i]);
                    } else if (key === 'abilityUnlock') {
                        let currentUnlocked = 0;
                        Object.keys(abilities).forEach(k => {
                            if (abilities[k].owned) currentUnlocked++;
                        });
                        currentProgress = Math.min(currentUnlocked, ach.milestones[i]);
                    }
                    
                    const progressPercent = (currentProgress / ach.milestones[i]) * 100;
                    
                    const progress = document.createElement('span');
                    progress.className = 'progress';
                    
                    if (key === 'dodge0') {
                        progress.textContent = `${currentProgress}/${ach.milestones[i]}`;
                    } else if (key === 'dodge1') {
                        progress.textContent = `${currentProgress}/${ach.milestones[i]}`;
                    } else if (key === 'dodge2') {
                        progress.textContent = `${currentProgress}/${ach.milestones[i]}`;
                    } else if (key === 'dodge3') {
                        progress.textContent = `${currentProgress}/${ach.milestones[i]}`;
                    } else if (key === 'dodge4') {
                        progress.textContent = `${currentProgress}/${ach.milestones[i]}`;
                    } else if (key === 'timeAlive') {
                        progress.textContent = `${currentProgress}/${ach.milestones[i]}—Å–µ–∫`;
                    } else if (key === 'maxUpgrades') {
                        let currentMaxed = 0;
                        Object.keys(upgrades).forEach(k => {
                            if (upgrades[k].level === maxLevel) currentMaxed++;
                        });
                        progress.textContent = `${currentMaxed}/${ach.milestones[i]}`;
                    } else if (key === 'abilityUnlock') {
                        let currentUnlocked = 0;
                        Object.keys(abilities).forEach(k => {
                            if (abilities[k].owned) currentUnlocked++;
                        });
                        progress.textContent = `${currentUnlocked}/${ach.milestones[i]}`;
                    }
                    
                    const progressBar = document.createElement('div');
                    progressBar.className = 'progress-bar';
                    const progressBarFill = document.createElement('div');
                    progressBarFill.className = 'progress-bar-fill';
                    progressBarFill.style.width = Math.min(progressPercent, 100) + '%';
                    progressBar.appendChild(progressBarFill);
                    
                    const points = document.createElement('span');
                    points.className = 'points';
                    points.textContent = `+${ach.points[i]} –æ—á–∫–æ–≤`;
                    
                    div.appendChild(name);
                    div.appendChild(progress);
                    div.appendChild(progressBar);
                    div.appendChild(points);
                    wrapper.appendChild(div);
                }
            });
            
            container.appendChild(wrapper);
        }

        // –ü—Ä–∏–º–µ–Ω–∏—Ç—å —É–ª—É—á—à–µ–Ω–∏—è
        function applyUpgrades() {
            player.maxHp = 5 + upgrades.hp.level * 5;
            player.hp = player.maxHp;
            currencyBonus = 1 + (upgrades.currency.level - 1) * 0.3;
            player.speed = 1 + upgrades.speed.level * 0.5;
            player.regen = upgrades.regen.level * 0.1;
            player.damageReduce = upgrades.damage.level * 0.06;
            frame.size = 200 + upgrades.frame.level * 50;
            frame.x = (canvas.width - frame.size) / 2;
            frame.y = (canvas.height - frame.size) / 2;
            
            // –†–∞–∑–º–µ—Ä –∏–≥—Ä–æ–∫–∞ —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è —Å —É–ª—É—á—à–µ–Ω–∏–µ–º
            player.baseSize = 90 - upgrades.shrink.level * 5;

            // –ß–∞—Å—Ç–æ—Ç–∞ —Å–ø–∞–≤–Ω–∞ –º–æ–Ω–µ—Ç
            const basePowerUpInterval = 10000;
            powerUpSpawnInterval = Math.max(2000, basePowerUpInterval - upgrades.powerup.level * 800);

            Object.keys(abilities).forEach(key => {
                let ab = abilities[key];
                ab.maxCharge = 5 + ab.level * 2;
                ab.charge = ab.maxCharge;
                ab.regen = 1 + ab.level * 0.2;
                ab.drainRate = 1 + ab.level * 0.5;
            });
        }

        // --- Skins shop data & functions ---
        const skinList = [
            { id: 1, name: '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π' },
            { id: 2, name: '–ó–µ–ª—ë–Ω—ã–π' },
            { id: 3, name: '–§–∏–æ–ª–µ—Ç–æ–≤—ã–π' },
            { id: 4, name: '–ú–æ–Ω–æ—Ö—Ä–æ–º–Ω—ã–π' },
            { id: 5, name: '–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π' },
            { id: 6, name: '–ö–æ–Ω—Ñ–µ—Ç–Ω–æ-–ø–∞—Å—Ç–µ–ª—å–Ω—ã–π' },
            { id: 7, name: '–ó–æ–ª–æ—Ç–æ–π' },
            { id: 8, name: '–ü–µ—Ä–µ–ª–∏–≤–∞—é—â–∏–π—Å—è' }
        ];
        // Adjusted prices so total is reachable by achievement points
        const skinCosts = { 1: 0, 2: 40, 3: 60, 4: 30, 5: 150, 6: 120, 7: 200, 8: 300 };
        // ownedSkins: { category: {skinId: true} }
        let ownedSkins = { player: {1: true}, background: {1: true}, frame: {1: true} };
        let selectedSkins = { player: 1, background: 1, frame: 1 };
        // Trails (player trails) - small visual trail following the player
        const trailList = [
            { id: 1, name: '–ù–µ—Ç' },
            { id: 2, name: '–ó–µ–ª—ë–Ω—ã–π —Å–ª–µ–¥' },
            { id: 3, name: '–§–∏–æ–ª–µ—Ç–æ–≤—ã–π —Å–ª–µ–¥' },
            { id: 4, name: '–ú–æ–Ω–æ—Ö—Ä–æ–º–Ω—ã–π —Å–ª–µ–¥' },
            { id: 5, name: '–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π —Å–ª–µ–¥' },
            { id: 6, name: '–ü–∞—Å—Ç–µ–ª—å–Ω—ã–π —Å–ª–µ–¥' },
            { id: 7, name: '–ó–æ–ª–æ—Ç–æ–π —Å–ª–µ–¥' },
            { id: 8, name: '–ü–µ—Ä–µ–ª–∏–≤–∞—é—â–∏–π—Å—è —Å–ª–µ–¥' }
        ];
        const trailCosts = { 1: 0, 2: 25, 3: 30, 4: 20, 5: 80, 6: 60, 7: 120, 8: 180 };
        let ownedTrails = { 1: true }; // default: no trail (id 1) owned
        let selectedTrail = 1;
        // Trail runtime buffer
        let trailPositions = [];

        function createSkinsMenu() {
            const container = document.getElementById('skinsSection');
            container.innerHTML = '';
            // Update inline achievement points
            const inline = document.getElementById('achievementPointsInline');
            if (inline) inline.textContent = achievementPoints;

            ['player', 'background', 'frame'].forEach(category => {
                const title = document.createElement('div');
                title.style.fontWeight = '700';
                title.style.margin = '6px 0';
                title.textContent = category === 'player' ? '–ò–≥—Ä–æ–∫' : (category === 'background' ? '–§–æ–Ω' : '–†–∞–º–∫–∞');
                container.appendChild(title);

                const row = document.createElement('div');
                row.className = 'skin-row';
                skinList.forEach(skin => {
                    const tile = document.createElement('div');
                    tile.className = 'skin-tile';
                    if (ownedSkins[category] && ownedSkins[category][skin.id]) tile.classList.add('skin-owned');
                    if (selectedSkins[category] === skin.id) tile.classList.add('skin-selected');

                    const preview = document.createElement('div');
                    preview.className = 'skin-preview';
                    // paint preview using skin colors
                    const colors = getSkinColors(category, skin.id);
                    preview.style.background = `linear-gradient(135deg, ${colors.start}, ${colors.end})`;
                    preview.style.borderColor = colors.accent;

                    const name = document.createElement('div');
                    name.style.fontSize = '11px';
                    name.style.textAlign = 'center';
                    name.textContent = skin.name;

                    const actions = document.createElement('div');
                    actions.className = 'skin-actions';
                    const btn = document.createElement('button');
                    if (selectedSkins[category] === skin.id) {
                        btn.textContent = 'Selected';
                        btn.style.background = '#ffff66';
                        btn.disabled = true;
                    } else if (ownedSkins[category] && ownedSkins[category][skin.id]) {
                        btn.textContent = 'Select';
                        btn.style.background = '#00ff88';
                        btn.addEventListener('click', () => selectSkin(category, skin.id));
                    } else {
                        const cost = skinCosts[skin.id] || 0;
                        btn.textContent = `Buy ${cost}`;
                        btn.style.background = '#00ccff';
                        btn.addEventListener('click', () => buySkin(category, skin.id));
                    }
                    actions.appendChild(btn);

                    tile.appendChild(preview);
                    tile.appendChild(name);
                    tile.appendChild(actions);
                    row.appendChild(tile);
                });
                container.appendChild(row);
            });

            // Trails section
            const trailTitle = document.createElement('div');
            trailTitle.style.fontWeight = '700';
            trailTitle.style.margin = '8px 0 6px 0';
            trailTitle.textContent = '–°–ª–µ–¥—ã –∏–≥—Ä–æ–∫–∞';
            container.appendChild(trailTitle);

            const trailRow = document.createElement('div');
            trailRow.className = 'skin-row';
            trailList.forEach(tr => {
                const tile = document.createElement('div');
                tile.className = 'skin-tile';
                if (ownedTrails[tr.id]) tile.classList.add('skin-owned');
                if (selectedTrail === tr.id) tile.classList.add('skin-selected');

                const preview = document.createElement('div');
                preview.className = 'skin-preview';
                // preview color
                const c = getTrailPreviewColors(tr.id);
                preview.style.background = `linear-gradient(135deg, ${c.start}, ${c.end})`;
                preview.style.borderColor = c.accent;

                const name = document.createElement('div');
                name.style.fontSize = '11px';
                name.style.textAlign = 'center';
                name.textContent = tr.name;

                const actions = document.createElement('div');
                actions.className = 'skin-actions';
                const btn = document.createElement('button');
                if (selectedTrail === tr.id) {
                    btn.textContent = 'Selected';
                    btn.style.background = '#ffff66';
                    btn.disabled = true;
                } else if (ownedTrails[tr.id]) {
                    btn.textContent = 'Select';
                    btn.style.background = '#00ff88';
                    btn.addEventListener('click', () => { selectedTrail = tr.id; saveProgress(); createSkinsMenu(); });
                } else {
                    const cost = trailCosts[tr.id] || 0;
                    btn.textContent = `Buy ${cost}`;
                    btn.style.background = '#00ccff';
                    btn.addEventListener('click', () => {
                        if (achievementPoints < cost) { alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π'); return; }
                        achievementPoints -= cost;
                        ownedTrails[tr.id] = true;
                        selectedTrail = tr.id;
                        saveProgress();
                        createSkinsMenu();
                        updateAchievementsDisplay();
                    });
                }
                actions.appendChild(btn);

                tile.appendChild(preview);
                tile.appendChild(name);
                tile.appendChild(actions);
                trailRow.appendChild(tile);
            });
            container.appendChild(trailRow);

            // wire toggle button (exists in DOM) to update its label
            const skinsToggle = document.getElementById('skinsToggle');
            const skinsWrapper = document.getElementById('skinsWrapper');
            const skinsContent = document.getElementById('skinsContent');
            if (skinsToggle && skinsWrapper) {
                skinsToggle.onclick = (e) => {
                    e.preventDefault();
                    skinsWrapper.classList.toggle('collapsed');
                    skinsToggle.textContent = skinsWrapper.classList.contains('collapsed') ? '–ü–æ–∫–∞–∑–∞—Ç—å' : '–°–∫—Ä—ã—Ç—å';
                };
                // set initial state collapsed to hide until user expands
                if (!skinsWrapper.dataset.initialized) {
                    skinsWrapper.classList.add('collapsed');
                    skinsToggle.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å';
                    skinsWrapper.dataset.initialized = '1';
                }
            }
        }

        function buySkin(category, skinId) {
            const cost = skinCosts[skinId] || 0;
            if (achievementPoints < cost) {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—á–∫–æ–≤ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π');
                return;
            }
            achievementPoints -= cost;
            ownedSkins[category] = ownedSkins[category] || {};
            ownedSkins[category][skinId] = true;
            saveProgress();
            createSkinsMenu();
            updateAchievementsDisplay();
        }

        function getTrailPreviewColors(trailId) {
            if (trailId === 8) {
                const h = Math.floor((skinAnimPhase * 60) % 360);
                return { start: `hsl(${h} 70% 40%)`, end: `hsl(${(h+60)%360} 70% 50%)`, accent: `hsl(${(h+30)%360} 75% 60%)` };
            }
            switch (trailId) {
                case 2: return { start: '#004422', end: '#00ff88', accent: '#00ff88' };
                case 3: return { start: '#2a0044', end: '#cc66ff', accent: '#aa44ff' };
                case 4: return { start: '#111111', end: '#777777', accent: '#bbbbbb' };
                case 5: return { start: '#001133', end: '#6611ff', accent: '#88ccff' };
                case 6: return { start: '#ffdbe6', end: '#ffeacc', accent: '#ff99cc' };
                case 7: return { start: '#443300', end: '#ffd700', accent: '#ffd700' };
                default: return { start: '#000000', end: '#222222', accent: '#666666' };
            }
        }

        function selectSkin(category, skinId) {
            if (!(ownedSkins[category] && ownedSkins[category][skinId])) return;
            selectedSkins[category] = skinId;
            applySkins();
            saveProgress();
            createSkinsMenu();
        }

        function applySkins() {
            // Initialize cosmetics depending on selection
            const bgColors = getSkinColors('background', selectedSkins.background);
            // If cosmic background selected, generate stars and use canvas-drawn stars
            if (selectedSkins.background === 5) {
                // remove static background color so star drawing is visible
                canvas.style.backgroundColor = 'transparent';
                ensureCosmicStars();
            } else {
                canvas.style.backgroundColor = bgColors.start;
            }

            // Gold sparkles should appear only when the player skin is gold
            if (selectedSkins.player === 7) {
                ensureGoldSparkles();
            } else {
                goldSparkles = [];
            }
        }

        function getSkinColors(category, skinId) {
            // Animated skin uses skinAnimPhase
            if (skinId === 8) {
                const h = Math.floor((skinAnimPhase * 60) % 360);
                return {
                    start: `hsl(${h} 78% 30%)`,
                    end: `hsl(${(h + 60) % 360} 78% 40%)`,
                    accent: `hsl(${(h + 30) % 360} 85% 50%)`
                };
            }
            if (category === 'player') {
                switch (skinId) {
                    case 2: return { start: '#006622', end: '#00ff88', accent: '#00ff88' };
                    case 3: return { start: '#2a0044', end: '#cc66ff', accent: '#aa44ff' };
                    case 4: return { start: '#222222', end: '#888888', accent: '#cccccc' };
                    case 5: return { start: '#0b1633', end: '#6633ff', accent: '#88ccff' };
                    case 6: return { start: '#ffdbe6', end: '#ffeacc', accent: '#ff99cc' };
                    case 7: return { start: '#5a4410', end: '#ffd700', accent: '#ffdd55' };
                    default: return { start: '#00ff88', end: '#00cc66', accent: '#00ff88' };
                }
            }
            if (category === 'background') {
                switch (skinId) {
                    case 2: return { start: '#001a0d', end: '#003322', accent: '#006644' };
                    case 3: return { start: '#0a0014', end: '#330033', accent: '#660066' };
                    case 4: return { start: '#050505', end: '#202020', accent: '#888888' };
                    case 5: return { start: '#000018', end: '#0b0033', accent: '#223366' };
                    case 6: return { start: '#fff6fb', end: '#fff9f2', accent: '#ffdcee' };
                    case 7: return { start: '#1e1400', end: '#3a2300', accent: '#6b4a00' };
                    default: return { start: '#0a0a0a', end: '#222222', accent: '#666666' };
                }
            }
            // frame
            switch (skinId) {
                case 2: return { start: '#003322', end: '#006644', accent: '#00ff88' };
                case 3: return { start: '#220044', end: '#aa66ff', accent: '#cc88ff' };
                case 4: return { start: '#111111', end: '#444444', accent: '#888888' };
                case 5: return { start: '#001133', end: '#6611ff', accent: '#88ccff' };
                case 6: return { start: '#ffe6f0', end: '#fff0e6', accent: '#ffb3d1' };
                case 7: return { start: '#443300', end: '#ffd700', accent: '#ffdd55' };
                default: return { start: '#002233', end: '#006677', accent: '#00ffff' };
            }
        }


        // –°–æ–∑–¥–∞—Ç—å –º–µ–Ω—é —É–ª—É—á—à–µ–Ω–∏–π
        function createUpgradeMenu() {
            const upgradesDiv = upgradeMenu.querySelector('.upgrades');
            upgradesDiv.innerHTML = '';
            Object.keys(upgrades).forEach(key => {
                const upgrade = upgrades[key];
                const div = document.createElement('div');
                div.className = 'upgrade';
                div.dataset.key = key;
                const fill = document.createElement('div');
                fill.className = 'fill';
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –∞–ø–≥—Ä–µ–π–¥–∞
                const startLevel = (key === 'powerup' || key === 'regen' || key === 'damage' || key === 'shrink') ? 0 : 1;
                const levelRange = maxLevel - startLevel;
                const currentProgress = (upgrade.level - startLevel) / levelRange;
                fill.style.height = `${Math.max(0, Math.min(100, currentProgress * 100))}%`;
                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = upgradeLabels[key];
                const cost = document.createElement('div');
                cost.className = 'cost';
                cost.textContent = upgrade.cost;
                div.appendChild(fill);
                div.appendChild(label);
                div.appendChild(cost);
                div.addEventListener('click', () => upgradeClick(key));
                upgradesDiv.appendChild(div);
            });

            const abilitiesDiv = upgradeMenu.querySelector('.abilities');
            abilitiesDiv.innerHTML = '';
            const abilitiesTitle = document.createElement('h3');
            abilitiesTitle.textContent = '–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏';
            abilitiesDiv.appendChild(abilitiesTitle);
            Object.keys(abilities).forEach(key => {
                const ab = abilities[key];
                const div = document.createElement('div');
                div.className = 'ability';
                if (activeAbility === key) div.classList.add('selected');
                div.dataset.key = key;
                div.textContent = abilityLabels[key];
                const cost = document.createElement('div');
                cost.className = 'cost';
                if (!ab.owned) {
                    cost.textContent = `–ö—É–ø–∏—Ç—å: ${ab.cost}`;
                    const buyButton = document.createElement('button');
                    buyButton.textContent = '–ö—É–ø–∏—Ç—å';
                    buyButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        buyAbility(key);
                    });
                    div.appendChild(cost);
                    div.appendChild(buyButton);
                } else {
                    cost.textContent = `–£—Ä–æ–≤–µ–Ω—å: ${ab.level}`;
                    const upgradeButton = document.createElement('button');
                    upgradeButton.textContent = `–£–ª—É—á—à–∏—Ç—å (${ab.cost + ab.level * 3})`;
                    upgradeButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        upgradeAbility(key);
                    });
                    const selectButton = document.createElement('button');
                    selectButton.className = 'select';
                    selectButton.textContent = '–í—ã–±—Ä–∞—Ç—å';
                    selectButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        selectAbility(key);
                    });
                    div.appendChild(cost);
                    div.appendChild(upgradeButton);
                    div.appendChild(selectButton);
                }
                abilitiesDiv.appendChild(div);
            });

            document.getElementById('currencyDisplay').textContent = Math.floor(getTotalCurrency());
            document.getElementById('abilityPoints').textContent = abilityPoints;
            document.getElementById('achievementPointsDisplay').textContent = achievementPoints;
            
            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ª—É—á—à–µ–µ –≤—Ä–µ–º—è
            const bestMinutes = Math.floor(maxTimeElapsed / 60);
            const bestSeconds = Math.floor(maxTimeElapsed % 60);
            const bestTimeFormatted = `${bestMinutes.toString().padStart(2, '0')}:${bestSeconds.toString().padStart(2, '0')}`;
            document.getElementById('bestTimeDisplay').textContent = bestTimeFormatted;

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –±–ª–æ–∫ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
            if (gameState !== 'playing') {
                document.getElementById('achievementsContainer').style.display = 'block';
                updateAchievementsDisplay();
            } else {
                document.getElementById('achievementsContainer').style.display = 'none';
            }
            // –°–æ–∑–¥–∞—ë–º –º–µ–Ω—é —Å–∫–∏–Ω–æ–≤
            createSkinsMenu();
        }

        function buyAbility(key) {
            const ab = abilities[key];
            if (abilityPoints >= ab.cost) {
                abilityPoints -= ab.cost;
                ab.owned = true;
                activeAbility = key;
                checkAchievements();
                createUpgradeMenu();
            }
        }

        function upgradeAbility(key) {
            const ab = abilities[key];
            const upgradeCost = ab.cost + ab.level * 3;
            if (abilityPoints >= upgradeCost) {
                abilityPoints -= upgradeCost;
                ab.level++;
                createUpgradeMenu();
            }
        }

        function selectAbility(key) {
            activeAbility = key;
            createUpgradeMenu();
        }

        function upgradeClick(key) {
            const upgrade = upgrades[key];
            if (upgrade.level >= maxLevel || getTotalCurrency() < upgrade.cost) return;
            spendCurrency(upgrade.cost);
            upgrade.level++;
            upgrade.cost += Math.floor(upgrade.cost * 0.5);
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞–∫—Å–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ø–≥—Ä–µ–π–¥—ã
            if (upgrade.level === maxLevel) {
                checkAchievements();
            }
            createUpgradeMenu();
        }

        function getTotalCurrency() {
            return Object.values(dodges).reduce((a, b) => a + b, 0);
        }

        function spendCurrency(amount) {
            let total = getTotalCurrency();
            if (total < amount) return;
            const types = Object.keys(dodges);
            const perType = Math.floor(amount / types.length);
            for (let type of types) {
                dodges[type] = Math.max(0, dodges[type] - perType);
            }
        }

        // –ú—ã—à—å
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) leftMouseDown = true;
        });
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) leftMouseDown = false;
        });
        canvas.addEventListener('mouseleave', () => leftMouseDown = false);

        // –ü–∞–Ω–µ–ª—å –æ—Ç–ª–∞–¥–∫–∏ (–∫–ª–∞–≤–∏—à–∞ P)
        const debugPanel = document.getElementById('debugPanel');
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'p') {
                debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
            }
        });

        document.getElementById('debugCurrency').addEventListener('click', () => {
            dodges[0] += 50;
            createUpgradeMenu();
        });
        document.getElementById('debugCoins').addEventListener('click', () => {
            abilityPoints += 50;
            createUpgradeMenu();
        });
        document.getElementById('debugTime').addEventListener('click', () => {
            timeElapsed += 10;
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∫–ª–∞–¥–æ–∫
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // –í–∫–ª–∞–¥–∫–∞ —Å–∫—Ä—ã—Ç–∞
            } else {
                // –í–∫–ª–∞–¥–∫–∞ —Å—Ç–∞–ª–∞ –≤–∏–¥–Ω–∞, —Å–±—Ä–æ—Å–∏—Ç—å –≤—Ä–µ–º—è
                lastTime = 0;
            }
        });

        // –°–±—Ä–æ—Å
        function resetGame() {
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.hp = player.maxHp;
            player.size = player.baseSize;
            projectiles = [];
            powerUps = [];
            timeBonuses = [];
            particles = [];
            projectileTypes = [0];
            lastSpawn = 0;
            spawnInterval = 1000;
            projectileSpeed = 2;
            timeElapsed = 0;
            lastMinute = 0;
            lastPowerUpSpawn = 0;
            screenShake = 0;
            Object.keys(abilities).forEach(key => {
                abilities[key].charge = abilities[key].maxCharge;
            });
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        function saveProgress() {
            const progressData = {
                upgrades: upgrades,
                abilities: abilities,
                abilityPoints: abilityPoints,
                dodges: dodges,
                maxTimeElapsed: maxTimeElapsed,
                achievements: achievements,
                achievementPoints: achievementPoints,
                dodgeCount: dodgeCount
                ,ownedSkins: ownedSkins,
                selectedSkins: selectedSkins,
                ownedTrails: ownedTrails,
                selectedTrail: selectedTrail,
                activeAbility: activeAbility
            };
            localStorage.setItem('blockDodgeProgress', JSON.stringify(progressData));
        }

        function loadProgress() {
            const savedData = localStorage.getItem('blockDodgeProgress');
            if (savedData) {
                try {
                    const progressData = JSON.parse(savedData);
                    upgrades = progressData.upgrades || upgrades;
                    abilities = progressData.abilities || abilities;
                    abilityPoints = progressData.abilityPoints || 0;
                    dodges = progressData.dodges || { 0: 0, 1: 0, 2: 0, 3: 0 };
                    maxTimeElapsed = progressData.maxTimeElapsed || 0;
                    // Merge saved achievement 'earned' flags instead of reassigning const
                    if (progressData.achievements) {
                        Object.keys(progressData.achievements).forEach(k => {
                            if (achievements[k] && Array.isArray(progressData.achievements[k].earned)) {
                                // copy earned flags up to expected length
                                achievements[k].earned = progressData.achievements[k].earned.slice(0, achievements[k].earned.length);
                            }
                        });
                    }
                    achievementPoints = progressData.achievementPoints || 0;
                    dodgeCount = progressData.dodgeCount || { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
                    // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ dodgeCount[4] —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                    if (dodgeCount[4] === undefined) dodgeCount[4] = 0;
                    ownedSkins = progressData.ownedSkins || ownedSkins;
                    selectedSkins = progressData.selectedSkins || selectedSkins;
                    ownedTrails = progressData.ownedTrails || ownedTrails;
                    selectedTrail = progressData.selectedTrail || selectedTrail;
                    activeAbility = progressData.activeAbility || null;
                    applyUpgrades();
                    applySkins();
                    createUpgradeMenu();
                } catch (e) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:', e);
                }
            }
        }

        function resetProgress() {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã? –í–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥–µ—Ç –ø–æ—Ç–µ—Ä—è–Ω!')) {
                localStorage.removeItem('blockDodgeProgress');
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —É–ª—É—á—à–µ–Ω–∏—è –∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
                upgrades = {
                    hp: { level: 1, cost: 10 },
                    currency: { level: 1, cost: 15 },
                    speed: { level: 1, cost: 20 },
                    regen: { level: 0, cost: 25 },
                    damage: { level: 0, cost: 20 },
                    frame: { level: 1, cost: 30 },
                    powerup: { level: 0, cost: 20 },
                    shrink: { level: 0, cost: 18 }
                };
                abilities = {
                    shield: { owned: false, cost: 5, level: 0, maxCharge: 5, charge: 5, regen: 1, drainRate: 1 },
                    shrink: { owned: false, cost: 5, level: 0, maxCharge: 5, charge: 5, regen: 1, drainRate: 1 },
                    slow: { owned: false, cost: 5, level: 0, maxCharge: 5, charge: 5, regen: 1, drainRate: 1 }
                };
                abilityPoints = 0;
                dodges = { 0: 0, 1: 0, 2: 0, 3: 0 };
                maxTimeElapsed = 0;
                activeAbility = null;
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
                Object.keys(achievements).forEach(key => {
                    achievements[key].earned = achievements[key].earned.map(() => false);
                });
                achievementPoints = 0;
                dodgeCount = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
                // –°–±—Ä–æ—Å —Å–∫–∏–Ω–æ–≤ –∏ —Å–ª–µ–¥–æ–≤
                ownedSkins = { player: {1: true}, background: {1: true}, frame: {1: true} };
                selectedSkins = { player: 1, background: 1, frame: 1 };
                ownedTrails = { 1: true };
                selectedTrail = 1;
                applyUpgrades();
                applySkins();
                createUpgradeMenu();
                alert('–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–±—Ä–æ—à–µ–Ω!');
            }
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ —Å–±—Ä–æ—Å–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        document.getElementById('resetProgressButton').addEventListener('click', resetProgress);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –∫–Ω–æ–ø–∫—É "–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ"
        const originalRestartHandler = document.getElementById('restartButton').onclick;
        document.getElementById('restartButton').addEventListener('click', () => {
            saveProgress();
            document.getElementById('resetProgressButton').classList.remove('visible');
            document.getElementById('authorLabel').classList.remove('visible');
            document.getElementById('achievementsContainer').style.display = 'none';
            applyUpgrades();
            resetGame();
            gameState = 'playing';
            upgradeMenu.style.display = 'none';
        });

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        loadProgress();

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –∑–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É
        window.addEventListener('beforeunload', () => {
            saveProgress();
        });

        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏
        document.getElementById('restartButton').onclick = null;



        // Power-up (–º–æ–Ω–µ—Ç–∞)
        function spawnPowerUp() {
            const x = frame.x + Math.random() * frame.size;
            const y = frame.y + Math.random() * frame.size;
            powerUps.push({ x, y, size: 15 });
        }

        // –í—Ä–µ–º–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å (+10 —Å–µ–∫—É–Ω–¥)
        function spawnTimeBonus() {
            const x = frame.x + Math.random() * frame.size;
            const y = frame.y + Math.random() * frame.size;
            timeBonuses.push({ x, y, size: 12, rotationAngle: 0 });
        }

        // –°–ø–∞–≤–Ω —Å–Ω–∞—Ä—è–¥–∞
        function spawnProjectile() {
            const type = projectileTypes[Math.floor(Math.random() * projectileTypes.length)];
            let p;
            if (type === 4) {
                // –£—Ä–æ–Ω –∑–æ–Ω—ã: —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ, –ø–æ—Ç–æ–º —Å–∞–º –∫—Ä—É–≥
                const circleX = frame.x + Math.random() * (frame.size - 100) + 50;
                const circleY = frame.y + Math.random() * (frame.size - 100) + 50;
                const circleRadius = 40 + Math.random() * 40;
                p = {
                    type: 4,
                    x: circleX,
                    y: circleY,
                    radius: circleRadius,
                    phase: 'warning',
                    warningTimer: 2.0,
                    damageTimer: 3.0,
                    dodged: false
                };
                // –ó–∞ –∑–æ–Ω—ã —É—Ä–æ–Ω–∞ +4 –≤–∞–ª—é—Ç—ã
                dodges[type] = (dodges[type] || 0) + 4 * currencyBonus;
            } else if (type === 2) {
                const isHorizontal = Math.random() < 0.5;
                const pos = isHorizontal ? player.y : player.x;
                p = { type: 2, isHorizontal, pos, phase: 'warning', timer: 1.5, activeDuration: 0.5, thickness: 10, dodged: false };
                // –ó–∞ –ª–∞–∑–µ—Ä—ã +5 –≤–∞–ª—é—Ç—ã
                dodges[type] = (dodges[type] || 0) + 5 * currencyBonus;
            } else if (type === 3) {
                const side = Math.floor(Math.random() * 4);
                let x, y, baseX, baseY, dx, dy;
                
                switch (side) {
                    case 0: baseX = Math.random() * (frame.size - 40) + frame.x + 20; baseY = frame.y; x = baseX; y = baseY - 40; dx = 0; dy = 1; break; // —Å–≤–µ—Ä—Ö—É
                    case 1: baseX = frame.x + frame.size; baseY = Math.random() * (frame.size - 40) + frame.y + 20; x = baseX + 40; y = baseY; dx = -1; dy = 0; break; // —Å–ø—Ä–∞–≤–∞
                    case 2: baseX = Math.random() * (frame.size - 40) + frame.x + 20; baseY = frame.y + frame.size; x = baseX; y = baseY + 40; dx = 0; dy = -1; break; // —Å–Ω–∏–∑—É
                    case 3: baseX = frame.x; baseY = Math.random() * (frame.size - 40) + frame.y + 20; x = baseX - 40; y = baseY; dx = 1; dy = 0; break; // —Å–ª–µ–≤–∞
                }
                
                p = { 
                    x, y, 
                    baseX, baseY, // –±–∞–∑–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è –≤—ã–¥–≤–∏–∂–µ–Ω–∏—è
                    dx, dy, 
                    size: 30, 
                    type: 3, 
                    dodged: false, 
                    width: 30, 
                    height: 30,
                    phase: 'warning',
                    warningTimer: 1.0,
                    extendTimer: 1.0,
                    extendDistance: 0,
                    maxExtend: 100,
                    extendSpeed: 2.5
                };
                // –ó–∞ –≤—ã–¥–≤–∏–∂–Ω—ã–µ —Å–Ω–∞—Ä—è–¥—ã +3 –≤–∞–ª—é—Ç—ã
                dodges[type] = (dodges[type] || 0) + 3 * currencyBonus;
            } else {
                const side = Math.floor(Math.random() * 4);
                let x, y, dx, dy;
                const targetX = player.x;
                const targetY = player.y;

                switch (side) {
                    case 0: x = Math.random() * canvas.width; y = -20; break;
                    case 1: x = canvas.width + 20; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height + 20; break;
                    case 3: x = -20; y = Math.random() * canvas.height; break;
                }

                const angle = Math.atan2(targetY - y, targetX - x);
                dx = Math.cos(angle) * projectileSpeed;
                dy = Math.sin(angle) * projectileSpeed;

                p = { x, y, dx, dy, size: 20, type, dodged: false };
                // –ó–∞ –æ–±—ã—á–Ω—ã–µ —Å–Ω–∞—Ä—è–¥—ã +1, –∑–∞ –≤—Ç–æ—Ä—ã–µ +3
                const reward = type === 0 ? 1 : 3;
                dodges[type] = (dodges[type] || 0) + reward * currencyBonus;
            }
            projectiles.push(p);
        }

        // –¶–∏–∫–ª
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const delta = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // advance skin animation phase (used by –ø–µ—Ä–µ–ª–∏–≤–∞—é—â–∏–π—Å—è skin)
            skinAnimPhase += delta * 0.9; // speed factor

            // –¢—Ä—è—Å–∫–∞ —ç–∫—Ä–∞–Ω–∞
            let shakeX = 0, shakeY = 0;
            if (screenShake > 0) {
                shakeX = (Math.random() - 0.5) * screenShake;
                shakeY = (Math.random() - 0.5) * screenShake;
                screenShake *= 0.95;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw cosmic starfield if selected (drawn behind everything)
            if (selectedSkins.background === 5 && cosmicStars.length > 0) {
                // draw stars directly onto ctx before save/translate so they don't jitter when screen shakes
                for (let i = 0; i < cosmicStars.length; i++) {
                    const s = cosmicStars[i];
                    const a = s.baseAlpha + Math.sin(s.phase + skinAnimPhase * s.speed) * 0.35;
                    ctx.globalAlpha = Math.max(0, Math.min(1, a));
                    ctx.fillStyle = 'white';
                    const r = s.size;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Å–º–µ—â–µ–Ω–∏—è
            ctx.save();
            ctx.translate(shakeX, shakeY);

            if (gameState === 'playing') {
                timeElapsed += delta;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
                if (timeElapsed > maxTimeElapsed) {
                    maxTimeElapsed = timeElapsed;
                }

                spawnInterval = Math.max(200, 1000 - timeElapsed * 10);
                projectileSpeed = 2 + timeElapsed * 0.1;

                const currentMinute = Math.floor(timeElapsed / 60);
                if (currentMinute > lastMinute) {
                    lastMinute = currentMinute;
                    if (currentMinute >= 1 && projectileTypes.length < 2) projectileTypes.push(1);
                    if (currentMinute >= 2 && projectileTypes.length < 3) projectileTypes.push(3);
                    if (currentMinute >= 3 && projectileTypes.length < 4) projectileTypes.push(2);
                    if (currentMinute >= 4 && projectileTypes.length < 5) projectileTypes.push(4);
                }

                if (timestamp - lastSpawn > spawnInterval) {
                    spawnProjectile();
                    lastSpawn = timestamp;
                }

                if (timestamp - lastPowerUpSpawn > powerUpSpawnInterval) {
                    spawnPowerUp();
                    // –†–µ–¥–∫–∏–π —Å–ø–∞–≤–Ω –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –±–æ–Ω—É—Å–∞ (–≤ 3 —Ä–∞–∑–∞ —Ä–µ–∂–µ, —á–µ–º –º–æ–Ω–µ—Ç—ã)
                    if (Math.random() < 0.2) {
                        spawnTimeBonus();
                    }
                    lastPowerUpSpawn = timestamp;
                }

                // Dynamic background for animated skin (background id 8)
                if (selectedSkins.background === 8) {
                    const bgH = Math.floor((skinAnimPhase * 60) % 360);
                    // subtle darker background animated hue
                    canvas.style.backgroundColor = `hsl(${bgH} 38% 10%)`;
                }

                // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
                const halfSize = player.size / 2;
                let targetX = Math.max(frame.x + halfSize, Math.min(mouse.x, frame.x + frame.size - halfSize));
                let targetY = Math.max(frame.y + halfSize, Math.min(mouse.y, frame.y + frame.size - halfSize));
                let dx = targetX - player.x;
                let dy = targetY - player.y;
                let dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    let moveDistance = player.speed * 60 * delta;
                    if (dist < moveDistance) {
                        player.x = targetX;
                        player.y = targetY;
                    } else {
                        player.x += (dx / dist) * moveDistance;
                        player.y += (dy / dist) * moveDistance;
                    }
                }

                // Update trail positions buffer
                if (selectedTrail && selectedTrail !== 1) {
                    trailPositions.push({ x: player.x, y: player.y, size: player.size });
                    const maxTrail = 60;
                    while (trailPositions.length > maxTrail) trailPositions.shift();
                } else {
                    // keep minimal buffer for 'no trail'
                    trailPositions = [];
                }

                player.hp = Math.min(player.maxHp, player.hp + player.regen * delta);

                // –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
                let slowFactor = 1;
                let shieldActive = false;
                if (leftMouseDown && activeAbility && abilities[activeAbility].charge > 0) {
                    const ab = abilities[activeAbility];
                    ab.charge -= ab.drainRate * delta;
                    if (ab.charge <= 0) {
                        ab.charge = 0;
                    } else {
                        switch (activeAbility) {
                            case 'shield': shieldActive = true; break;
                            case 'shrink': player.size = player.baseSize * 0.5; break;
                            case 'slow': slowFactor = 0.5; break;
                        }
                    }
                } else {
                    player.size = player.baseSize;
                }

                // –†–µ–≥–µ–Ω –∑–∞—Ä—è–¥–∞ (—Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
                Object.keys(abilities).forEach(key => {
                    let ab = abilities[key];
                    if (!(leftMouseDown && activeAbility === key)) {
                        if (ab.charge < ab.maxCharge) {
                            ab.charge += ab.regen * delta;
                            if (ab.charge > ab.maxCharge) ab.charge = ab.maxCharge;
                        }
                    }
                });

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx * delta * 60;
                    p.y += p.vy * delta * 60;
                    p.life -= delta;
                    p.vy += 0.2; // –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }

                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    
                    // –£—Ä–æ–Ω –∑–æ–Ω—ã (—Ç–∏–ø 4)
                    if (p.type === 4) {
                        if (p.phase === 'warning') {
                            p.warningTimer -= delta;
                            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—é—â–µ–≥–æ –∫—Ä—É–≥–∞
                            ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(Date.now() / 100) * 0.2})`;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            if (p.warningTimer <= 0) {
                                p.phase = 'damage';
                                p.timer = p.damageTimer;
                            }
                        } else if (p.phase === 'damage') {
                            p.timer -= delta;
                            
                            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∫—Ä—É–≥–∞ —É—Ä–æ–Ω–∞
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
                            const dx = player.x - p.x;
                            const dy = player.y - p.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < p.radius + player.size / 2 && !shieldActive) {
                                player.hp -= 1 * (1 - player.damageReduce);
                                screenShake = 15;
                                p.dodged = true;
                                // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ —É–¥–∞—Ä–µ
                                for (let j = 0; j < 8; j++) {
                                    const angle = (Math.PI * 2 * j) / 8;
                                    particles.push({
                                        x: player.x,
                                        y: player.y,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3,
                                        life: 0.5,
                                        color: '#ff0000'
                                    });
                                }
                            } else if (dist < p.radius + player.size / 2 && shieldActive) {
                                p.dodged = true;
                            }
                            
                            if (p.timer <= 0) {
                                // –ó–æ–Ω–∞ —É—Ä–æ–Ω–∞ –∏–∑–±–µ–∂–∞–Ω–∞
                                if (!p.dodged) {
                                    dodgeCount[4]++;
                                    checkAchievements();
                                }
                                projectiles.splice(i, 1);
                                continue;
                            }
                        }
                        continue;
                    }
                    
                    if (p.type === 2) {
                        p.timer -= delta;
                        if (p.timer <= 0) {
                            if (p.phase === 'warning') {
                                p.phase = 'active';
                                p.timer = p.activeDuration;
                            } else {
                                // –õ–∞–∑–µ—Ä –±—ã–ª —É—Å–ø–µ—à–Ω–æ –∏–∑–±–µ–∂–∞–Ω (–µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è)
                                if (!p.dodged) {
                                    dodgeCount[2]++;
                                    checkAchievements();
                                }
                                projectiles.splice(i, 1);
                                continue;
                            }
                        }

                        ctx.strokeStyle = p.phase === 'warning' ? '#ffff00' : '#ff0088';
                        ctx.lineWidth = p.thickness;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = p.phase === 'warning' ? '#ffff00' : '#ff0088';
                        if (p.phase === 'warning') ctx.setLineDash([10, 10]);
                        ctx.beginPath();
                        if (p.isHorizontal) {
                            ctx.moveTo(frame.x, p.pos);
                            ctx.lineTo(frame.x + frame.size, p.pos);
                        } else {
                            ctx.moveTo(p.pos, frame.y);
                            ctx.lineTo(p.pos, frame.y + frame.size);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.shadowBlur = 0;

                        if (p.phase === 'active') {
                            let hit = false;
                            if (p.isHorizontal) {
                                hit = Math.abs(p.pos - player.y) < (p.thickness / 2 + player.size / 2);
                            } else {
                                hit = Math.abs(p.pos - player.x) < (p.thickness / 2 + player.size / 2);
                            }
                            if (hit && !shieldActive) {
                                player.hp -= 1 * (1 - player.damageReduce);
                                screenShake = 15;
                                p.dodged = true;
                                // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ —É–¥–∞—Ä–µ
                                for (let j = 0; j < 8; j++) {
                                    const angle = (Math.PI * 2 * j) / 8;
                                    particles.push({
                                        x: player.x,
                                        y: player.y,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3,
                                        life: 0.5,
                                        color: '#ff0088'
                                    });
                                }
                            } else if (hit && shieldActive) {
                                p.dodged = true;
                            }
                        }
                    } else {
                        p.x += p.dx * delta * 60 * slowFactor;
                        p.y += p.dy * delta * 60 * slowFactor;

                        if (p.type === 1) {
                            const angle = Math.atan2(player.y - p.y, player.x - p.x);
                            p.dx += Math.cos(angle) * 0.05 * slowFactor;
                            p.dy += Math.sin(angle) * 0.05 * slowFactor;
                            const speed = Math.sqrt(p.dx**2 + p.dy**2);
                            if (speed > 0) {
                                p.dx = (p.dx / speed) * projectileSpeed * slowFactor;
                                p.dy = (p.dy / speed) * projectileSpeed * slowFactor;
                            }
                        }

                        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–¥–≤–∏–∂–Ω—ã—Ö —Å–Ω–∞—Ä—è–¥–æ–≤ —Ç–∏–ø–∞ 3
                        if (p.type === 3) {
                            if (p.phase === 'warning') {
                                p.warningTimer -= delta;
                                if (p.warningTimer <= 0) {
                                    p.phase = 'extend';
                                    p.extendTimer = 1.0;
                                }
                            } else if (p.phase === 'extend') {
                                p.extendDistance += p.extendSpeed * 60 * delta * slowFactor;
                                if (p.extendDistance >= p.maxExtend) {
                                    p.extendDistance = p.maxExtend;
                                    p.phase = 'retract';
                                    p.extendTimer = 1.0;
                                }
                                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                                p.x = p.baseX + p.dx * p.extendDistance;
                                p.y = p.baseY + p.dy * p.extendDistance;
                            } else if (p.phase === 'retract') {
                                p.extendDistance -= p.extendSpeed * 60 * delta * slowFactor;
                                if (p.extendDistance <= 0) {
                                    // –í—ã–¥–≤–∏–∂–Ω–æ–π —Å–Ω–∞—Ä—è–¥ –±—ã–ª —É—Å–ø–µ—à–Ω–æ –∏–∑–±–µ–∂–∞–Ω
                                    dodgeCount[3]++;
                                    checkAchievements();
                                    projectiles.splice(i, 1);
                                    continue;
                                }
                                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                                p.x = p.baseX + p.dx * p.extendDistance;
                                p.y = p.baseY + p.dy * p.extendDistance;
                            }
                        }

                        const collision = Math.hypot(p.x - player.x, p.y - player.y) < (p.size + player.size)/2;
                        if (shieldActive && collision) {
                            // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ –æ—Ç—Ä–∞–∂–µ–Ω–∏–∏ —â–∏—Ç–æ–º
                            for (let j = 0; j < 12; j++) {
                                const angle = (Math.PI * 2 * j) / 12;
                                particles.push({
                                    x: p.x,
                                    y: p.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    life: 0.6,
                                    color: '#00ffff'
                                });
                            }
                            projectiles.splice(i, 1);
                            continue;
                        } else if (!shieldActive && collision && (p.type !== 3 || p.phase === 'extend')) {
                            player.hp -= 1 * (1 - player.damageReduce);
                            screenShake = 15;
                            // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏
                            for (let j = 0; j < 10; j++) {
                                const angle = (Math.PI * 2 * j) / 10;
                                particles.push({
                                    x: p.x,
                                    y: p.y,
                                    vx: Math.cos(angle) * 3.5,
                                    vy: Math.sin(angle) * 3.5,
                                    life: 0.6,
                                    color: p.type === 0 ? '#ff3333' : (p.type === 1 ? '#ff8833' : '#ff33ff')
                                });
                            }
                            projectiles.splice(i, 1);
                            continue;
                        }

                        if (p.type !== 3 && (p.x < -p.size || p.x > canvas.width + p.size || p.y < -p.size || p.y > canvas.height + p.size)) {
                            // –û–±—ã—á–Ω—ã–π —Å–Ω–∞—Ä—è–¥ –±—ã–ª —É—Å–ø–µ—à–Ω–æ –∏–∑–±–µ–∂–∞–Ω
                            dodgeCount[p.type]++;
                            checkAchievements();
                            projectiles.splice(i, 1);
                            continue;
                        }

                        if (p.type === 3) {
                            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤—ã–¥–≤–∏–∂–Ω—ã—Ö —Å–Ω–∞—Ä—è–¥–æ–≤
                            if (p.phase === 'warning') {
                                // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ - –º–∏–≥–∞—é—â–∏–π –∫–≤–∞–¥—Ä–∞—Ç
                                const alpha = (Math.sin(p.warningTimer * Math.PI * 5) + 1) / 2;
                                ctx.globalAlpha = alpha * 0.7;
                                ctx.strokeStyle = '#ffff00';
                                ctx.lineWidth = 3;
                                ctx.setLineDash([5, 5]);
                                ctx.strokeRect(p.baseX - 15, p.baseY - 15, 30, 30);
                                ctx.setLineDash([]);
                                ctx.globalAlpha = 1;
                            } else {
                                // –í—ã–¥–≤–∏–∂–µ–Ω–∏–µ/–∑–∞–¥–≤–∏–∂–µ–Ω–∏–µ - –∑–∞–∫—Ä–∞—à–µ–Ω–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç
                                const gradient = ctx.createLinearGradient(p.x - p.width/2, p.y - p.height/2, p.x + p.width/2, p.y + p.height/2);
                                gradient.addColorStop(0, '#ff33ff');
                                gradient.addColorStop(1, '#ff00ff');
                                ctx.fillStyle = gradient;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = '#ff00ff';
                                ctx.fillRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);
                                ctx.shadowBlur = 0;
                            }
                        } else {
                            const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size / 2);
                            gradient.addColorStop(0, p.type === 0 ? '#ff6666' : '#ffaa66');
                            gradient.addColorStop(1, p.type === 0 ? '#ff0000' : '#ff6600');
                            ctx.fillStyle = gradient;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = p.type === 0 ? '#ff0000' : '#ff6600';
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                }

                // –ú–æ–Ω–µ—Ç—ã (power-ups)
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const pu = powerUps[i];
                    if (Math.hypot(pu.x - player.x, pu.y - player.y) < (pu.size + player.size)/2) {
                        abilityPoints++;
                        // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ –ø–æ–¥–±–æ—Ä–µ –º–æ–Ω–µ—Ç—ã
                        for (let j = 0; j < 15; j++) {
                            const angle = (Math.PI * 2 * j) / 15;
                            particles.push({
                                x: pu.x,
                                y: pu.y,
                                vx: Math.cos(angle) * 2.5,
                                vy: Math.sin(angle) * 2.5,
                                life: 0.5,
                                color: '#ffff00'
                            });
                        }
                        powerUps.splice(i, 1);
                        continue;
                    }
                    const gradient = ctx.createRadialGradient(pu.x, pu.y, 0, pu.x, pu.y, pu.size / 2);
                    gradient.addColorStop(0, '#ffff66');
                    gradient.addColorStop(1, '#ffcc00');
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(pu.x, pu.y, pu.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', pu.x, pu.y);
                }

                // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –±–æ–Ω—É—Å—ã
                for (let i = timeBonuses.length - 1; i >= 0; i--) {
                    const tb = timeBonuses[i];
                    tb.rotationAngle += 0.05;
                    if (Math.hypot(tb.x - player.x, tb.y - player.y) < (tb.size + player.size)/2) {
                        timeElapsed += 10;
                        // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ –ø–æ–¥–±–æ—Ä–µ
                        for (let j = 0; j < 20; j++) {
                            const angle = (Math.PI * 2 * j) / 20;
                            particles.push({
                                x: tb.x,
                                y: tb.y,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                life: 0.6,
                                color: '#00ffff'
                            });
                        }
                        timeBonuses.splice(i, 1);
                        continue;
                    }
                    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –±–æ–Ω—É—Å–∞ –∫–∞–∫ –≤—Ä–∞—â–∞—é—â–µ–π—Å—è –∑–≤—ë–∑–¥–æ—á–∫–∏
                    ctx.save();
                    ctx.translate(tb.x, tb.y);
                    ctx.rotate(tb.rotationAngle);
                    
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const angle = (j * 4 * Math.PI) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * tb.size;
                        const y = Math.sin(angle) * tb.size;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }

                // –†–∞–º–∫–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∫–∏–Ω)
                const frameCols = getSkinColors('frame', selectedSkins.frame);
                ctx.strokeStyle = frameCols.accent || frameCols.start;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = frameCols.accent || frameCols.start;
                ctx.strokeRect(frame.x, frame.y, frame.size, frame.size);
                ctx.shadowBlur = 0;

                // –ò–≥—Ä–æ–∫ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∫–∏–Ω)
                // Render trail (if selectedTrail != 1)
                if (selectedTrail && selectedTrail !== 1 && trailPositions.length > 0) {
                    const len = trailPositions.length;
                    for (let i = 0; i < len; i++) {
                        const tp = trailPositions[i];
                        const t = i / len; // 0..1 older..newer
                        const alpha = Math.max(0, (1 - (len - i) / len) * 0.9);
                        const sizeScale = 0.6 + (i / len) * 0.8;
                        const sz = tp.size * sizeScale * 0.6;
                        const cols = getTrailPreviewColors(selectedTrail);
                        // for animated trail, compute dynamic colors
                        let start = cols.start, end = cols.end;
                        if (selectedTrail === 8) {
                            const h = Math.floor((skinAnimPhase * 60 + i * 5) % 360);
                            start = `hsl(${h} 70% 40%)`;
                            end = `hsl(${(h+60)%360} 70% 50%)`;
                        }
                        ctx.globalAlpha = alpha;
                        const g = ctx.createLinearGradient(tp.x - sz/2, tp.y - sz/2, tp.x + sz/2, tp.y + sz/2);
                        g.addColorStop(0, start);
                        g.addColorStop(1, end);
                        ctx.fillStyle = g;
                        ctx.fillRect(tp.x - sz/2, tp.y - sz/2, sz, sz);
                        ctx.globalAlpha = 1;
                    }
                }
                const halfSizePlayer = player.size / 2;
                const playerCols = getSkinColors('player', selectedSkins.player);
                const playerGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, halfSizePlayer);
                playerGradient.addColorStop(0, playerCols.start);
                playerGradient.addColorStop(1, playerCols.end);
                ctx.fillStyle = playerGradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = playerCols.accent;
                ctx.fillRect(player.x - halfSizePlayer, player.y - halfSizePlayer, player.size, player.size);
                ctx.shadowBlur = 0;

                // HP –∫–∞–∫ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç—å –∫–≤–∞–¥—Ä–∞—Ç–∞ —Å–Ω–∏–∑—É (—Ü–≤–µ—Ç –ø–æ –∞–∫—Ü–µ–Ω—Ç—É —Å–∫–∏–Ω–∞)
                const hpFillHeight = (player.hp / player.maxHp) * player.size;
                ctx.fillStyle = playerCols.accent;
                ctx.shadowBlur = 15;
                ctx.shadowColor = playerCols.accent;
                ctx.fillRect(player.x - halfSizePlayer, player.y - halfSizePlayer + player.size - hpFillHeight, player.size, hpFillHeight);
                ctx.shadowBlur = 0;

                // –©–∏—Ç (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–∫—Ü–µ–Ω—Ç —Ñ—Ä–µ–π–º–∞)
                if (shieldActive) {
                    ctx.strokeStyle = frameCols.accent || '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = frameCols.accent || '#00ffff';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size / 1.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // –ü–æ–ª–æ—Å–∞ –∑–∞—Ä—è–¥–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
                if (activeAbility) {
                    const ab = abilities[activeAbility];
                    const chargeFill = ab.charge / ab.maxCharge;
                    const barWidth = player.size * 1.4;
                    const barHeight = 6;
                    const barY = player.y + halfSizePlayer + 12;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(player.x - barWidth/2, barY, barWidth, barHeight);
                    const chargeGradient = ctx.createLinearGradient(player.x - barWidth/2, 0, player.x - barWidth/2 + barWidth * chargeFill, 0);
                    chargeGradient.addColorStop(0, '#ff00ff');
                    chargeGradient.addColorStop(1, '#00ffff');
                    ctx.fillStyle = chargeGradient;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.fillRect(player.x - barWidth/2, barY, barWidth * chargeFill, barHeight);
                    ctx.shadowBlur = 0;
                }

                // Gold sparkles (when gold skin selected) - render before generic particles
                if (goldSparkles && goldSparkles.length > 0) {
                    for (let i = 0; i < goldSparkles.length; i++) {
                        const sp = goldSparkles[i];
                        sp.angle += sp.speed * delta;
                        const gx = player.x + Math.cos(sp.angle) * sp.radius;
                        const gy = player.y + Math.sin(sp.angle) * sp.radius;
                        const glow = 0.5 + 0.5 * Math.sin(skinAnimPhase * 6 + sp.phase);
                        ctx.globalAlpha = Math.max(0, Math.min(1, glow));
                        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, sp.size * 2 + 2);
                        g.addColorStop(0, '#fff9e6');
                        g.addColorStop(0.4, '#fff1b0');
                        g.addColorStop(1, 'rgba(255,215,0,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath();
                        ctx.arc(gx, gy, sp.size + 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }

                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —á–∞—Å—Ç–∏—Ü
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 0.6;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                });

                // –¢–∞–π–º–µ—Ä –≤ —Å—Ç–∏–ª–µ
                const minutes = Math.floor(timeElapsed / 60);
                const seconds = Math.floor(timeElapsed % 60);
                const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                ctx.font = 'bold 32px "Orbitron", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.fillText(`‚è± ${formattedTime}`, canvas.width / 2, 15);
                ctx.shadowBlur = 0;

                // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤–∞–ª—é—Ç—ã –≤ –ª–µ–≤–æ–º —É–≥–ª—É
                ctx.font = 'bold 18px "Orbitron", monospace';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffff00';
                ctx.fillText(`üí∞ ${Math.floor(getTotalCurrency())}`, 20, 20);
                ctx.shadowBlur = 0;

                if (player.hp <= 0) {
                    gameState = 'upgrading';
                    checkAchievements();
                    upgradeMenu.style.display = 'block';
                    document.getElementById('resetProgressButton').classList.add('visible');
                    document.getElementById('authorLabel').classList.add('visible');
                    createUpgradeMenu();
                }
            }

            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        applySkins();
        applyUpgrades();
        createUpgradeMenu();
        requestAnimationFrame(gameLoop);
    </script>
</body>

</html>

